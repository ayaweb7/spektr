<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../css/screen.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../js/mistakes.js"></script>
<link rel="shortcut icon" type="image/ico" href="images/favicon.ico" />

<title>Обработка ошибок в JS</title>
</head>

	<body name="top">
<!-- !!!!!!!!!!!!!!!!!       шаблоны, заготовки для тэгов, комментарии !!!!!!!!!!!!!!! -->

<!-- Абзацы, заголовки, комментарии -->
<h4></h4>
<p>

</br>
</p>
<p></p>
<!-- Это комментарий HTML -->



<?php
/* 
Это область
многострочного комментария,
которая не будет
подвергаться интерпретации 
*/
?>

<!-- Шаблон для PHP кода с комментариями внутри кода -->
<h4></h4>
<p>

</br>
</p>
<p></p>
<?php
// 


// 

?>

<table id="inventory" class="realty">
	<tr><th></th><th></th><th></th></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
</table>

<h1 style='color: blue;'></h1>
<?php  ?>
<!-- !!!!!!!!!!!!!!!!!       шаблоны, заготовки для тэгов, комментарии !!!!!!!!!!!!!!! -->

<h4>Документ validate.html (часть первая)</h4>
<p>
Рассмотрим стандартную регистрационную форму, используемую большинством сайтов, на которых работать можно только зарегистрированным пользователям.<br>
В форме будут запрашиваться имя, фамилия, пользовательское имя, пароль, возраст и адрес электронной почты.
</p>
<p>Пример 17.1. Форма с проверкой данных средствами JavaScript (часть первая)</p>
<p>
!DOCTYPE html><br>
html><br>
head><br><br>
title>Пример формы/title><br><br>
style><br>
.signup {<br>
border: 1px solid #999999;<br>
font: normal 14px helvetica;<br>
color:#444444;<br>
}<br>
/style><br><br>
script><br>
function validate(form) {<br>
fail = validateForename(form.forename.value)<br>
fail += validateSurname(form.surname.value)<br>
fail += validateUsername(form.username.value)<br>
fail += validatePassword(form.password.value)<br>
fail += validateAge(form.age.value)<br>
fail += validateEmail(form.email.value)<br>
if (fail == "") return true<br>
else { alert(fail); return false }<br>
}<br>
/script><br>
/head><br><br>
body><br>
table class="signup" border="0" cellpadding="2"<br>
cellspacing="5" bgcolor="#eeeeee"><br><br>
th colspan="2" align="center">Регистрационная форма/th><br>
form method="post" action="js_17_mistakes.php"<br>
onSubmit="return validate(this)"><br><br>
tr>td>Имя/td>td>input type="text" maxlength="32"<br>
name="forename">/td>/tr><br>
tr>td>Фамилия/td>td>input type="text" maxlength="32"<br>
name="surname">/td>/tr><br>
tr>td>Пользовательское имя/td><br>
td>input type="text" maxlength="16"<br>
name="username">/td>/tr><br>
tr>td>Пароль/td><br>
td>input type="text" maxlength="12"<br>
name="password">/td>/tr><br>
tr>td>Возраст/td><br>
td>input type="text" maxlength="3"<br>
name="age">/td>/tr><br>
tr>td>Электронный адрес/td><br>
td>input type="text" maxlength="64"<br>
name="email">/td>/tr><br>
tr>td colspan="2" align="center"><br>
input type="submit" value="Зарегистрироваться">/td>/tr><br><br>
/form><br>
/table><br>
/body><br>
/html>
</p>

<p style='color: blue;'>Start code</p>

<table class="signup" border="0" cellpadding="2" cellspacing="5" bgcolor="#eeeeee">
<th colspan="2" align="center">Регистрационная форма</th>
	<form method="post" action="js_17_mistakes.php" onSubmit="return validate(this)">
		<tr>
			<td>Имя</td>
			<td><input type="text" maxlength="32" name="forename"></td>
		</tr>
		<tr>
			<td>Фамилия</td>
			<td><input type="text" maxlength="32" name="surname"></td>
		</tr>
		<tr>
			<td>Пользовательское имя</td>
			<td><input type="text" maxlength="16" name="username"></td>
		</tr>
		<tr>
			<td>Пароль</td>
			<td><input type="text" maxlength="12" name="password"></td>
		</tr>
		<tr>
			<td>Возраст</td>
			<td><input type="text" maxlength="3" name="age"></td>
		</tr>
		<tr>
			<td>Электронный адрес</td>
			<td><input type="text" maxlength="64" name="email"></td>
		</tr>
		<tr>
			<td colspan="2" align="center"><input type="submit" value="Зарегистрироваться"></td></tr>
	</form>
</table>

<p>
В теги script> и /script> заключена всего одна функция по имени validate, которая, в свою очередь, вызывает шесть других функций,
проверяющих каждое из имеющихся в форме полей.<br>
они возвращают либо пустую строку, если поле проходит проверку, либо сообщение об ошибке, если оно эту проверку не проходит.<br>
При наличии любых ошибок сообщения о них выводятся в окне предупреждения, появляющемся благодаря последней строке сценария.
</p>
<p>
Если поле проходит проверку, то проводившая ее функция возвращает значение true, а если не проходит — false.
Значения, возвращаемые функцией validate, учитываются при отправке данных формы: если она возвращает false, данные не отправляются.<br>
При этом пользователь получает возможность закрыть появившееся окно предупреждения и внести изменения в данные.
Если будет возвращено значение true, значит, ошибок в полях формы не найдено и форму можно отправлять на сервер.
</p>
<p>
Во второй части этого примера показан код HTML для формы, где каждое поле и его имя помещены в отдельную строку таблицы.<br>
В этом HTML нет ничего сложного, за исключением инструкции onSubmit="return validate(this)", помещенной в открывающий тег form>.
Использование атрибута onSubmit позволяет при отправке формы вызвать избранную вами функцию.<br>
Эта функция может выполнить проверку и вернуть значение либо true, либо false, для того чтобы известить о том, разрешена или нет отправка формы.
</p>
<p>
Параметр this указывает на текущий объект (то есть на данную форму).
Он передается только что рассмотренной функции validate, которая получает этот параметр в виде объекта form.<br>
внутри HTML-формы JavaScript используется только для того, чтобы вызвать инструкцию return, помещенную в атрибут onSubmit.
</p>

<h4>Документ validate.html (часть вторая)</h4>
<p>
Теперь обратимся к коду примера 17.2, содержащему набор из шести функций, осуществляющих проверку полей формы.
</p>
<p>Пример 17.2. Форма, проверяемая средствами JavaScript (вторая часть)</p>
<p>
function validateForename(field)<br>
{<br>
return (field == "") ? "Не введено имя.\n" : ""<br>
}<br><br>
function validateSurname(field)<br>
{<br>
return (field == "") ? "Не введена фамилия.\n" : ""<br>
}<br><br>
function validateUsername(field)<br>
{<br>
if (field == "") return "Не введено имя пользователя.\n"<br>
else if (field.length < 5)<br>
return "В имени пользователя должно быть не менее 5 символов.\n"<br>
else if (/[^a-zA-Z0-9_-]/.test(field))<br>
return "В имени пользователя разрешены только a-z, A-Z, 0-9, - и _.\n"<br>
return ""<br>
}<br><br>
function validatePassword(field) {<br>
if (field == "") return "Не введен пароль.\n"<br>
else if (field.length < 6)<br>
return "В пароле должно быть не менее 6 символов.\n"<br>
else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||<br>
!/[0-9]/.test(field))<br>
return "Пароль требует 1 символа из каждого набора a-z, A-Z и 0-9.\n"<br>
return ""<br>
}<br><br>
function validateAge(field) {<br>
if (isNaN(field)) return "Не введен возраст.\n"<br>
else if (field < 18 || field > 110)<br>
return "Возраст должен быть между 18 и 110.\n"<br>
return ""<br>
}<br><br>
function validateEmail(field) {<br>
if (field == "") return "Не введен адрес электронной почты.\n"<br>
else if (!((field.indexOf(".") > 0) &&<br>
(field.indexOf("@") > 0)) ||<br>
/[^a-zA-Z0-9.@_-]/.test(field))<br>
return "Электронный адрес имеет неверный формат.\n"<br>
return ""<br>
}
</p>

<h4>Проверка имени</h4>
<p>
Предельно лаконичная функция validateForename воспринимает параметр field, являющийся значением имени (forename), переданным ей функцией validate.<br>
Если это значение является пустой строкой, возвращается сообщение об ошибке, если нет, то возвращается пустая строка,
свидетельствующая о том, что ошибка не обнаружена.
</p>
<p>
Если пользователь введет в это поле пробелы, то они будут приняты функцией validateForename, хотя в качестве имени они не годятся.<br>
Этот просчет можно исправить, добавив еще одну инструкцию, удаляющую из поля пустые пространства перед его проверкой на незаполненность,
затем воспользоваться регулярным выражением, чтобы убедиться в том, что в поле находится еще что-нибудь, кроме пробелов,
или — как это сделано в данном случае — позволить пользователю допустить эту ошибку и «отловить» ее на сервере.
</p>

<h4>Проверка фамилии</h4>
<p>
Код функции validateSurname похож на код функции validateForename, он также возвращает сообщение об ошибке,
если в качестве фамилии (surname) была предоставлена пустая строка.<br>
Я решил не накладывать ограничений на символы обоих полей, чтобы пользователь мог вводить символы, не входящие в английский алфавит,
имеющие дополнительные знаки и т. д.
</p>

<h4>Проверка имени пользователя</h4>
<p>
Код функции validateUsername немного интереснее, поскольку выполняет более сложную работу. Он должен разрешить использование только тех символов, которые входят в набор a–z, A–Z, 0–9, _ и -,
и гарантировать, что имена пользователей состоят не менее чем из пяти символов.
</p>
<p>
Код структуры if...else начинается с возвращения сообщения об ошибке в том случае, если поле не было заполнено.<br>
Если значение поля не является пустой строкой, но состоит менее чем из пяти символов, то возвращается другое сообщение об ошибке.
</p>
<p>
Затем вызывается JavaScript-функция test, которая сравнивает регулярное выражение
(соответствующее любому символу, не входящему в перечень разрешенных) с содержимым поля (см. раздел «Регулярные выражения» данной главы).<br>
Встретив хотя бы один недопустимый символ, функция test возвращает true, в результате чего функция validateUsername возвращает сообщение об ошибке.
</p>

<h4>Проверка пароля</h4>
<p>
Такая же технология используется и в функции validatePassword.<br>
Сначала функция проверяет поле на пустоту, возвращая сообщение об ошибке при незаполненном поле.
Затем сообщение об ошибке возвращается в том случае, если пароль короче шести символов.
</p>
<p>
Одно из требований, предъявляемых к паролям, заключается в том, что в них должно быть хотя бы по одному символу в нижнем и в верхнем регистре,
а также хотя бы одна цифра, поэтому функция test вызывается три раза, по одному разу на каждую из этих проверок.<br>
Если при любом из таких вызовов будет возвращено значение false, это будет говорить о том, что одно из условий не выполнено,
поэтому будет возвращено сообщение об ошибке.<br>
В противном случае будет возвращена пустая строка, свидетельствующая о том, что с паролем все в порядке.
</p>

<h4>Проверка возраста</h4>
<p>
Функция validateAge возвращает сообщение об ошибке, если значение поля не является числом (что определяется вызовом функции isNaN)
либо введенный возраст меньше 18 или больше 110 лет.<br>
У ваших приложений могут быть иные требования к возрастной категории или вообще не быть никаких требований.
При успешной проверке также будет возвращена пустая строка.
</p>

<h4>Проверка адреса электронной почты</h4>
<p>
И последняя, наиболее сложная проверка — адреса электронной почты — выполняется с помощью функции validateEmail.<br>
После проверки на существование каких-нибудь введенных данных и возвращения сообщения об ошибке при отсутствии таковых
функция дважды вызывает JavaScript-функцию indexOf.<br>
При первом вызове проверяется наличие точки (.), начиная со второго символа, а при втором — присутствие символа @, также начиная со второго символа.
</p>
<p>
Если будут пройдены эти две проверки, вызывается функция test, чтобы проверить поле на наличие недопустимых символов.
Если любая из этих проверок не будет пройдена, то возвращается сообщение об ошибке.<br>
Допустимыми в адресе электронной почты считаются буквы в нижнем и верхнем регистрах, символы подчеркивания, тире, точки и символ @.
Все они перечислены в регулярном выражении, передаваемом методу test.<br>
Если не будет найдено ни одной ошибки, возвращается пустая строка, свидетельствующая об успешно пройденной проверке.
</p>

<h4>Использование отдельного файла JavaScript</h4>
<p>
Конечно, благодаря универсальности своей конструкции и применимости ко многим типам потенциально востребуемых проверок эти шесть функций
становятся идеальными кандидатами для выделения в отдельный файл.<br>
Этот файл, к примеру, можно назвать validate_functions.js и включить его сразу же после начального блока сценария в пример 17.1,
используя следующую инструкцию:<br>
script src="validate_functions.js">/script>
</p>

<h4>Регулярные выражения<br> Соответствие, закладываемое в метасимволы</h4>
<p>
Любое регулярное выражение должно быть заключено в слеши (/).<br>
Конкретные символы, находящиеся внутри этих слешей, называются метасимволами и имеют специальное предназначение.<br>
Например, звездочка (*) имеет аналогичное (но не вполне такое же) значение, как и звездочки, уже встречавшиеся вам в оболочке или в командной строке Windows.
Звездочка означает следующее:<br> «Текст, подвергаемый сравнению, может содержать любое количество указанного перед ней символа или не содержать его вообще».
</p>
<p>
К примеру, вы ищете имя Le Guin и знаете, что оно может быть написано как с пробелом, так и без него.<br>
Из-за не вполне обычной разметки текста (кто-нибудь, например, мог вставить лишние пробелы, чтобы выровнять строки по правому краю)
нужно вести поиск в следующей строке:<br>
The difficulty of classifying Le Guin's works
</p>
<p>
Иначе говоря, шаблон должен соответствовать строке LeGuin, а также отдельно строкам Le и Guin, разделенным любым количеством пробелов.
Решением может стать установка после пробела звездочки:<br>
/Le *Guin/
</p>
<p>
В строке, кроме имени Le Guin, присутствует множество других символов, но этот шаблон все равно будет работать.
Поскольку регулярное выражение соответствует какой-то части строки, проверочная функция вернет истинное значение.
</p>
<p>
Предположим, что известно о непременном наличии хотя бы одного пробела.
В таком случае можно воспользоваться знаком «плюс» (+), поскольку этот метасимвол требует присутствия хотя бы одного из предшествующих ему символов:<br>
/Le +Guin/
</p>

<h4>Нестрогое символьное соответствие</h4>
<p>
Одним из самых полезных метасимволов является точка (.), поскольку она может соответствовать любому символу, за исключением символа новой строки.<br>
Предположим, что выполняется поиск HTML-тегов, которые начинаются с символа < и заканчиваются символом >.
Проще всего найти тег с помощью следующего регулярного выражения:<br>
/<.*>/
</p>
<p>
(.) Точка соответствует любому символу, а звездочка (*) расширяет действие точки до соответствия нулевому или любому другому количеству символов,
что означает:<br> «Соответствует всему, что заключено между символами < и >, даже если там ничего нет».<br>
Этот шаблон будет соответствовать строкам <>, <em>, <br> и т. д.
Но если не требуется, чтобы он соответствовал отсутствию символов <>, нужно вместо символа * использовать символ +:<br>
/<.+>/
</p>
<p>
Знак «плюс» расширяет действие точки до соответствия одному или нескольким символам, что означает:<br>
«Соответствует всему, что находится между символами < и >, пока между ними есть хотя бы один символ».
Этот шаблон будет соответствовать em> и /em>, h1> и /h1 и тегам с атрибутами, например:<br>
a href="www.mozilla.org"><br><br>
К сожалению, знак «плюс» расширит соответствие вплоть до последнего символа > в строке, поэтому соответствовать шаблону будет и такая строка:<br>
h1>b>Введение/b>/h1>
</p>
<p>
Если между угловыми скобками использовать только точку и не ставить за ней знаков + или *, то она будет соответствовать любому одиночному символу,
а шаблон будет соответствовать таким тегам, как b> и i>, но не будет соответствовать тегам em> или textarea>.
</p>
<p>
Если нужно, чтобы соответствие относилось к символу точки (.) как таковому, его действие нужно отключить, поставив перед ним символ обратного слеша (\),
поскольку в противном случае точка будет считаться метасимволом, соответствующим любому символу.<br>
К примеру, если нужен шаблон, соответствующий числу с плавающей точкой 5.0, то в нем можно будет использовать следующее регулярное выражение:<br>
/5\.0/
</p>
<p>
Только что мы рассмотрели шаблон соответствия числу с плавающей точкой.<br>
Но вам наверняка понадобится проверить соответствие не только строке 5.0, но и строке 5.,
поскольку обе содержат значение одного и того же числа с плавающей точкой.<br>
Нужно будет также проверить соответствие строкам 5.00, 5.000 и т. д., ведь разрешено использовать любое количество нулей.
Это можно сделать добавлением звездочки:<br>
/5\.0*/
</p>

<h4>Группировка с помощью скобок</h4>
<p>
Предположим, что нужно найти соответствие таким возрастающим степеням, как кило-, мега-, гига- и тера-.
Иными словами, нужно найти соответствие следующим строкам:<br>
1,000<br>
1,000,000<br>
1,000,000,000<br>
1,000,000,000,000<br>
...
</p>
<p>
Здесь мог бы пригодиться знак «плюс», но нужно сгруппировать строку ,000 так, чтобы действие этого знака распространялось на нее целиком.
Для этого служит следующее регулярное выражение:<br>
/1(,000)+ /
</p>
<p>
Скобки означают:<br> «При применении какого-нибудь метасимвола наподобие знака “плюс” все это нужно рассматривать как группу».<br>
Строки 1,00,000 и 1,000,00 не будут соответствовать шаблону, поскольку в тексте должен быть символ 1, за которым следует одна или несколько групп,
состоящих из запятой и трех нулей.
</p>
<p>
Пробел после знака «плюс» показывает, что соответствие должно закончиться, как только встретится пробел.<br>
Без этого пробела строка 1,000,00 будет вычислена соответствующей шаблону, поскольку в расчет будет приниматься только ее первая часть 1,000,
а оставшаяся часть ,00 будет проигнорирована.
Пробел нужен после остальных символов шаблона, чтобы обеспечить продолжение поиска соответствия шаблону до конца числа.
</p>

<h4>Символьный класс</h4>
<p>
Иногда требуется установить нестрогое соответствие, но не настолько пространное, чтобы для этого использовать точку.
Нестрогость придает регулярным выражениям огромную мощность: она позволяет регулировать строгость и нестрогость в соответствии с вашими желаниями.
</p>
<p>
Одним из ключевых элементов поддержки нестрогости соответствия является пара квадратных скобок [].<br>
Эта пара, как и точка, соответствует всего одному символу, но в эти скобки помещается перечень всех возможных соответствий.
При появлении любого из символов этого перечня текст будет соответствовать шаблону.
Например, если нужно, чтобы шаблону соответствовали оба написания — американское gray и английское grey, можно задать следующее регулярное выражение:<br>
/gr[ae]y/
</p>
<p>
В сравниваемой части текста после gr может быть либо a, либо e.
Но должна быть только одна из этих букв: все, что помещается внутри квадратных скобок, соответствует лишь одному символу.<br>
Группа символов внутри скобок называется символьным классом.
</p>

<h4>Указание диапазона</h4>
<p>
Для указания диапазона внутри квадратных скобок можно использовать дефис (-).
Одной из самых распространенных задач является проверка соответствия отдельной цифре, в которой можно использовать диапазон:<br>
/[0-9]/
</p>
<p>
Цифры являются настолько распространенным элементом регулярных выражений, что для их представления используется отдельный символ \d.
Его можно использовать для проверки соответствия цифре вместо регулярного выражения в квадратных скобках:<br>
/\d/
</p>

<h4>Инвертирование</h4>
<p>
За счет помещения знака вставки (^) после открывающей квадратной скобки можно превратить весь символьный класс в его противоположность.
После этого он будет означать:<br> «Соответствует любому символу, за исключением следующих».
</p>
<p>
Предположим, нужно найти экземпляры строк Yahoo, в которых отсутствует следующий за ними восклицательный знак.
(Официальное название компании содержит восклицательный знак!) Для этого можно использовать такое регулярное выражение:<br>
/Yahoo[^!]/
</p>
<p>
Вообще-то, это не самое лучшее решение задачи.<br>
Например, это выражение не позволяет найти соответствие, если Yahoo находится в конце строки, поскольку тогда за этим словом не следует что-нибудь,
а содержимому квадратных скобок должен соответствовать один символ.
</p>

<h4>Более сложные примеры</h4>
<p>
Рассматриваемое решение позволяет шаблону не пропустить закрывающую угловую скобку отдельного тега, но по-прежнему соответствовать таким тегам,
как em> и /em>, а также тегам с атрибутами, таким как:<br>
a href="www.mozilla.org">
Один из вариантов такого решения выглядит следующим образом:<br>
/<[^>]+>/
</p>
<p>
Разобьем это выражение на части.<br> На рис. 17.3 показан последовательный анализ всех его элементов.<br>
Вот эти элементы:<br>
1. / — открывающий слеш, указывающий на то, что это регулярное выражение;<br>
2. < — открывающая угловая скобка тега HTML. Требует точного соответствия, поскольку не является метасимволом;<br>
3. [^>] — символьный класс. Сочетание знака вставки и закрывающей угловой скобки ^> означает: «Соответствует всему, кроме закрывающей угловой скобки»;<br>
4. + — допускает любое количество символов, соответствующих предыдущему регулярному выражению [^>], если есть хотя бы один соответствующий ему символ;<br>
5. > — закрывающая угловая скобка тега HTML. Требует точного соответствия;<br>
6. / — закрывающий слеш, указывающий на конец регулярного выражения.
</p>
<p>
Теперь рассмотрим одно из выражений из примера 17.1, которое использовалось в функции validateUsername:<br>
/[^a-zA-Z0-9_]/
</p>
<p>
Рассмотрим эти элементы более подробно:<br>
1. / — открывающий слеш, указывающий на то, что это регулярное выражение;<br>
2. [ — открывающая квадратная скобка, с которой начинается символьный класс;<br>
3. ^ — символ инвертирования: инвертирует все, что находится в скобках;<br>
4. a–z — представляет любую букву в нижнем регистре;<br>
5. A–Z — представляет любую букву в верхнем регистре;<br>
6. 0–9 — представляет любую цифру;<br>
7. _ — символ подчеркивания;<br>
8. – — тире;<br>
9. ] — квадратная скобка, закрывающая символьный класс;<br>
10. / — закрывающий слеш, указывающий на конец регулярного выражения.
</p>
<p>
Есть еще пара весьма важных метасимволов. Они «закрепляют» регулярное выражение, требуя его применения в определенном месте.<br>
Если знак вставки (^) присутствует в начале регулярного выражения, то соответствующее выражению строковое значение должно быть в начале строки текста,
иначе оно не будет соответствовать шаблону.<br>
По аналогии с этим, если знак доллара ($) ставится в конце регулярного выражения, то соответствующее выражению строковое значение должно
находиться в конце строки текста.
</p>
<p>
Знак вставки (^) может запутать ситуацию, поскольку внутри квадратных скобок он означает «инвертировать символьный класс»,
а в начале регулярного выражения — «соответствовать началу строки».<br>
К сожалению, один и тот же символ служит для достижения совершенно разных целей, поэтому при его использовании следует быть особенно внимательными.
</p>
<p>
Закончим изучение основ регулярных выражений ответом на ранее заданный вопрос:<br>
предположим, вам нужно убедиться в том, что в строке нет больше ничего, кроме того, что соответствует регулярному выражению.
Что делать в том случае, если нужна строка текста, в которой нет ничего, кроме Le Guin?
Можно усовершенствовать ранее рассмотренное регулярное выражение, закрепив его сразу с двух сторон:<br>
/^Le *Guin$/
</p>

<h4>Сводная таблица метасимволов</h4>
<table id="inventory" class="realty">
	<tr><th>Метасимволы</th><th>Описание</th></tr>
	<tr><td>/</td><td>Начало и конец регулярного выражения</td></tr>
	<tr><td>.</td><td>Соответствует любому одному символу, кроме символа новой строки</td></tr>
	<tr><td>Элемент*</td><td>Соответствует появлению элемента от нуля и более раз</td></tr>
	<tr><td>Элемент +</td><td>Соответствует появлению элемента от одного и более раз</td></tr>
	<tr><td>Элемент?</td><td>Соответствует появлению элемента от нуля до одного раза</td></tr>
	<tr><td>[Символы]</td><td>Соответствует одному из тех символов, которые содержатся в квадратных скобках</td></tr>
	<tr><td>[^символы]</td><td>Соответствует одному из тех символов, которые не содержатся в квадратных скобках</td></tr>
	<tr><td>(regex)</td><td>Рассматривает regex (сокращение, означающее регулярное выражение) как группу для вычисления или для рассмотрения с одним из следующих метасимволов: *, + или ?</td></tr>
	<tr><td>Левое|правое</td><td>Соответствует либо левому, либо правому</td></tr>
	<tr><td>[l–r]</td><td>Соответствует диапазону символов между l и r</td></tr>
	<tr><td>^</td><td>Требует, чтобы соответствие было в начале строки</td></tr>
	<tr><td>$</td><td>Требует, чтобы соответствие было в конце строки</td></tr>
	<tr><td>\b</td><td>Соответствует границе слова</td></tr>
	<tr><td>\B</td><td>Соответствует при отсутствии границы слова</td></tr>
	<tr><td>\d</td><td>Соответствует одной цифре</td></tr>
	<tr><td>\D</td><td>Соответствует одному символу, не являющемуся цифрой</td></tr>
	<tr><td>\n</td><td>Соответствует символу новой строки</td></tr>
	<tr><td>\s</td><td>Соответствует пробелу</td></tr>
	<tr><td>\S</td><td>Соответствует символу, не являющемуся пробелом</td></tr>
	<tr><td>\t</td><td>Соответствует символу табуляции</td></tr>
	<tr><td>\w</td><td>Соответствует символу, используемому в словах (a–z, A–Z, 0–9 и _)</td></tr>
	<tr><td>\W</td><td>Соответствует символу, не используемому в словах (все, кроме a–z, A–Z, 0–9 и _)</td></tr>
	<tr><td>\x</td><td>Соответствует x (применяется, если x является метасимволом, но нужен символ x как таковой)</td></tr>
	<tr><td>{n}</td><td>Соответствует в точности n появлениям</td></tr>
	<tr><td>{n,}</td><td>Соответствует n и более появлениям</td></tr>
	<tr><td>{min,max}</td><td>Соответствует как минимум min и как максимум max появлениям</td></tr>
</table>

<p>
После изучения этой таблицы и повторного исследования выражения /[^a-zA-Z0-9_]/ можно понять, что оно легко и просто укорачивается до /[^\w]/,
так как отдельный метасимвол \w (с буквой w в нижнем регистре) указывает на символы a–z, A–Z, 0–9 и _.<br>
Можно проявить еще большую наблюдательность и заметить, что метасимвол \W (с буквой W в верхнем регистре) указывает на все символы,
за исключением a–z, A–Z, 0–9 и _.
Это позволяет избавиться также от метасимвола ^ и использовать для выражения только символы /[\W]/.
</p>
<p>Таблица 17.2. Примеры регулярных выражений</p>
<table id="inventory" class="realty">
	<tr><th>Пример</th><th>Соответствие</th></tr>
	<tr><td>r</td><td>Первая r в The quick brown</td></tr>
	<tr><td>rec[ei][ei]ve</td><td>Либо receive, либо recieve (но также и receeve или reciive)</td></tr>
	<tr><td>rec[ei]{2}ve</td><td>Либо receive, либо recieve (но также и receeve или reciive)</td></tr>
	<tr><td>rec(ei|ie)ve</td><td>Либо receive, либо recieve (но не receeve или reciive)</td></tr>
	<tr><td>cat</td><td>Слово cat в I like cats and dogs</td></tr>
	<tr><td>cat|dog</td><td>Любое из слов cat или dog в I like cats and dogs</td></tr>
	<tr><td>\.</td><td>Символ . (Знак \ необходим, так как . является метасимволом)</td></tr>
	<tr><td>5\.0*</td><td>5., 5.0, 5.00, 5.000 и т. д.</td></tr>
	<tr><td>[a–f]</td><td>Любой из символов a, b, c, d, e или f</td></tr>
	<tr><td>cats$</td><td>Только последнее слово cats в My cats are friendly cats</td></tr>
	<tr><td>^my</td><td>Только первое my в my cats are my pets</td></tr>
	<tr><td>\d{2,3}</td><td>Любое двух- или трехзначное число (от 00 до 999)</td></tr>
	<tr><td>7(,000)+</td><td>7,000; 7,000,000; 7,000,000,000; 7,000,000,000,000 и т. д.</td></tr>
	<tr><td>[\w]+</td><td>Любое слово из одного или нескольких символов</td></tr>
	<tr><td>[\w]{5}</td><td>Любое слово из пяти символов</td></tr>
</table>


<h4>Общие модификаторы</h4>
<p>
В регулярных выражениях можно применять следующие модификаторы.<br>
1. /g — допускает «глобальное» соответствие.
Применяется с функцией замены, что позволяет выполнить замену во всех соответствующих местах, а не только в месте первого соответствия.<br>
2. /i — отключает в регулярном выражении чувствительность к регистру букв. Иными словами, вместо /[a-zA-Z]/ можно указать /[a-z]/i или /[A-Z]/i.<br>
3. /m — допускает многострочный режим работы, в котором знак вставки (^) и знак доллара ($) соответствуют позициям перед любыми символами новой строки
в сравниваемой строковой переменной и после них. Обычно при поиске соответствия в многострочной строковой переменной знак ^
соответствует только позиции в ее начале, а символ $ — в ее конце.<br>
</p>
<p>
Например, выражение /cats/g будет соответствовать обоим появлениям слова cats в предложении I like cats and cats like me.<br>
Аналогично этому выражение /dogs/gi будет соответствовать обоим появлениям слова dogs (Dogs и dogs) в предложении Dogs like other dogs,
поскольку эти модификаторы допускают совместное использование.
</p>

<h4>Использование регулярных выражений в PHP</h4>
<p>
В PHP наиболее часто используются следующие функции, в которых применяются регулярные выражения: preg_match, preg_match_all и preg_replace.<br>
Чтобы проверить присутствие слова cats в любом месте строки, в любой комбинации букв в нижнем и верхнем регистрах, можно воспользоваться функцией preg_match:<br>
$n = preg_match("/cats/i", "Cats are fun. I like cats.");
</p>
<p>
Поскольку в PHP используется значение 1 для TRUE и значение 0 для FALSE, предыдущая инструкция присвоит переменной $n значение 1.
Первым аргументом функции служит регулярное выражение, а вторым — текст, проверяемый на соответствие.
</p>
<p>
Но функция preg_match способна выполнять более сложную задачу, поскольку она воспринимает еще и третий аргумент,
который показывает, какой именно текст соответствовал регулярному выражению:<br>
$n = preg_match("/cats/i", "Cats are fun. I like cats.", $match);<br>
echo "Количество соответсвий $n: $match[0]";
</p>
<p>
Третий аргумент является массивом (здесь ему присвоено имя $match).<br>
Функция помещает текст, соответствующий регулярному выражению, в первый элемент массива, поэтому, если соответствие будет найдено,
соответствующий регулярному выражению текст может быть найден в элементе $match[0].
В данном примере выводимая на экран информация покажет, что соответствующий текст начинался с прописной буквы:<br>
Количество соответствий 1: Cats
</p>
<p>
Если нужно определить все соответствия, используется функция preg_match_all:<br>
$n = preg_match_all("/cats/i", "Cats are fun. I like cats.", $match);<br>
echo "Количество соответствий $n: ";<br>
for ($j=0 ; $j < $n ; ++$j) echo $match[0][$j]." ";<br><br>
Как и в предыдущем случае, функции передан массив $match и элементу $match[0] присваиваются найденные соответствия,
только теперь они представляют собой подмассив.
Для отображения содержимого подмассива в этом примере осуществляется последовательный перебор его элементов с помощью цикла for.
</p>
<p>
Если нужно заменить часть строки, можно воспользоваться функцией preg_replace.
В этом примере все встречающиеся слова cats, независимо от регистра букв, заменяются словами dogs:<br>
echo preg_replace("/cats/i", "dogs", "Cats are fun. I like cats.");
</p>

<h4>Повторное отображение формы после проверки данных PHP-программой</h4>
<p>
На данный момент нами создан HTML-документ validate.html, который будет отправлен PHP-программе adduser.php,
но это произойдет только в том случае, если поля пройдут проверку средствами JavaScript или если JavaScript отключен или недоступен.
</p>
<p>Пример 17.3. Программа adduser.php</p>
<p>
$forename = $surname = $username = $password = $age = $email = "";<br>
if (isset($_POST['forename']))<br><br>

$forename = fix_string($_POST['forename']);<br>
if (isset($_POST['surname']))<br>
$surname = fix_string($_POST['surname']);<br>
if (isset($_POST['username']))<br>
$username = fix_string($_POST['username']);<br>
if (isset($_POST['password']))<br>
$password = fix_string($_POST['password']);<br>
if (isset($_POST['age']))<br>
$age = fix_string($_POST['age']);<br>
if (isset($_POST['email']))<br>
$email = fix_string($_POST['email']);<br><br>

$fail = validate_forename($forename);<br>
$fail .= validate_surname($surname);<br>
$fail .= validate_username($username);<br>
$fail .= validate_password($password);<br>
$fail .= validate_age($age);<br>
$fail .= validate_email($email);<br><br>

echo "<!DOCTYPE html>\nhtml>head>title>Пример формы/title>";<br>
if ($fail == "")<br>
{<br>
echo "/head>body>Проверка формы прошла успешно:<br>
$forename, $surname, $username, $password, $age,$email.<br>
/body>/html>";<br><br>

// В этом месте отправленные поля будут вводиться в базу данных<br>
// с предварительным использованием хеш-шифрования для пароля<br>
exit;<br>
}<br><br>

// Теперь выводится HTML и код JavaScript<br>
echo <<<_END<br><br>

Раздел HTML и JavaScript --><br>
style><br>
.signup {<br>
border: 1px solid #999999;<br>
font: normal 14px helvetica; color:#444444;<br>
}<br>
/style><br><br>

script><br>
function validate(form)<br>
{<br>
fail = validateForename(form.forename.value)<br>
fail += validateSurname(form.surname.value)<br>
fail += validateUsername(form.username.value)<br>
fail += validatePassword(form.password.value)<br>
fail += validateAge(form.age.value)<br>
fail += validateEmail(form.email.value)<br><br>

if (fail == "") return true<br>
else { alert(fail); return false }<br>
}<br>
function validateForename(field)<br>
{<br>
return (field == "") ? "Не введено имя.\n" : ""<br>
}<br>
function validateSurname(field)<br>
{<br>
return (field == "") ? "Не введена фамилия.\n" : ""<br>
}<br>
function validateUsername(field)<br>
{<br>
if (field == "") return "Не введено имя пользователя.\n"<br>
else if (field.length < 5)<br>
return "В имени пользователя должно быть не менее 5 символов.\n"<br>
else if (/[^a-zA-Z0-9_-]/.test(field))<br>
return "В имени пользователя разрешены только a-z, A-Z, 0-9, - и _.\n"<br>
return ""<br>
}<br>
function validatePassword(field)<br>
{<br>
if (field == "") return "Не введен пароль.\n"<br>
else if (field.length < 6)<br>
return "В пароле должно быть не менее 6 символов.\n"<br>
else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||<br>
! /[0-9]/.test(field))<br>
return "Пароль требует 1 символа из каждого набора a-z, A-Z и 0-9.\n"<br>
return ""<br>
}<br>
function validateAge(field)<br>
{<br>
if (isNaN(field)) return "Не введен возраст.\n"<br>
else if (field < 18 || field > 110)<br>
return "Возраст должен быть между 18 и 110.\n"<br>
return ""<br>
}<br>
function validateEmail(field)<br>
{<br>
if (field == "") return "Не введен адрес электронной почты.\n"<br>
else if (!((field.indexOf(".") > 0) &&<br>
(field.indexOf("@") > 0)) ||<br>
/[^a-zA-Z0-9.@_-]/.test(field))<br>
return "Электронный адрес имеет неверный формат.\n"<br>
return ""<br>
}<br><br>

/script><br>
/head><br>
body><br>

table border="0" cellpadding="2" cellspacing="5"<br>
bgcolor="#eeeeee"><br>
th colspan="2" align="center">Регистрационная форма/th><br>
tr>td colspan="2">К сожалению, в вашей форме br><br>
найдены следующие ошибки: p>font color=red<br>
size=1>i>$fail/i>/font>/p><br>
/td>/tr><br><br>

// PHP-функции<br>
function validate_forename($field)<br>
{<br>
return ($field == "") ? "Не введено имя br>" : "";<br>
}<br>
function validate_surname($field)<br>
{<br>
return ($field == "") ? "Не введена фамилияbr> : "";<br>
}<br>
function validate_username($field)<br>
{<br>
if ($field == "") return "Не введено имя пользователяbr>";<br>
else if (strlen($field) < 5)<br>
return "В имени пользователя должно быть не менее 5 символовbr>";<br>
else if (preg_match("/[^a-zA-Z0-9_-]/", $field))<br>
return "В имени пользователя допускаются только буквы, цифры, - и _br>";<br>
return "";<br>
}<br>
function validate_password($field)<br>
{<br>
if ($field == "") return "Не введен парольbr>";<br>
else if (strlen($field) < 6)<br>
return "В пароле должно быть не менее 6 символовbr>";<br>
else if ( !preg_match("/[a-z]/", $field) ||<br>
!preg_match("/[A-Z]/", $field) ||<br>
!preg_match("/[0-9]/", $field))<br>
return "Пароль требует 1 символа из каждого набора a-z, A-Z и 0-9br>";<br>
return "";<br>
}<br>
function validate_age($field)<br>
{<br>
if ($field == "") return "Не введен возрастbr>";<br>
else if ($field < 18 || $field > 110)<br>
return "Возраст должен быть между 18 и 110br>";<br>
return "";<br>
}<br>
function validate_email($field)<br>
{<br>
if ($field == "") return "Не введен адрес электронной почтыbr>";<br>
else if (!((strpos($field, ".") > 0) &&<br>
(strpos($field, "@") > 0)) ||<br>
preg_match("/[^a-zA-Z0-9.@_-]/", $field))<br>
return "Электронный адрес имеет неверный форматbr>";<br>
return "";<br>
}<br>
function fix_string($string)<br>
{<br>
if (get_magic_quotes_gpc()) $string = stripslashes($string);<br>
return htmlentities ($string);<br>
}<br>
?><br>


</p>

<p style='color: blue;'>Start code</p>


php 
$forename = $surname = $username = $password = $age = $email = "";

if (isset($_POST['forename'])) $forename = fix_string($_POST['forename']);
if (isset($_POST['surname'])) $surname = fix_string($_POST['surname']);
if (isset($_POST['username'])) $username = fix_string($_POST['username']);
if (isset($_POST['password'])) $password = fix_string($_POST['password']);
if (isset($_POST['age'])) $age = fix_string($_POST['age']);
if (isset($_POST['email'])) $email = fix_string($_POST['email']);

$fail = validate_forename($forename);
$fail .= validate_surname($surname);
$fail .= validate_username($username);
$fail .= validate_password($password);
$fail .= validate_age($age);
$fail .= validate_email($email);

if ($fail == "")
{
echo "<p>Проверка формы прошла успешно:
$forename, $surname, $username, $password, $age, $email.
</p>";
// В этом месте отправленные поля будут вводиться в базу данных
// с предварительным использованием хеш-шифрования для пароля
exit;
}
// Теперь выводится HTML и код JavaScript
echo <<<_END
<!-- Раздел HTML и JavaScript 
<style>
.signup {
border: 1px solid #999999;
font: normal 14px helvetica; color:#444444;
}
</style>
<script>
function validate(form)
{
fail = validateForename(form.forename.value)
fail += validateSurname(form.surname.value)
fail += validateUsername(form.username.value)
fail += validatePassword(form.password.value)
fail += validateAge(form.age.value)
fail += validateEmail(form.email.value)
if (fail == "") return true
else { alert(fail); return false }
}
function validateForename(field)
{
return (field == "") ? "Не введено имя.\n" : ""
}
function validateSurname(field)
{
return (field == "") ? "Не введена фамилия.\n" : ""
}
function validateUsername(field)
{
if (field == "") return "Не введено имя пользователя.\n"
else if (field.length < 5)
return "В имени пользователя должно быть не менее 5 символов.\n"
else if (/[^a-zA-Z0-9_-]/.test(field))
return "В имени пользователя разрешены только a-z, A-Z, 0-9, - и _.\n"
return ""
}
function validatePassword(field)
{
if (field == "") return "Не введен пароль.\n"
else if (field.length < 6)
return "В пароле должно быть не менее 6 символов.\n"
else if (!/[a-z]/.test(field) || ! /[A-Z]/.test(field) ||
! /[0-9]/.test(field))
return "Пароль требует 1 символа из каждого набора a-z, A-Z и 0-9.\n"
return ""
}
function validateAge(field)
{
if (isNaN(field)) return "Не введен возраст.\n"
else if (field < 18 || field > 110)
return "Возраст должен быть между 18 и 110.\n"
return ""
}
function validateEmail(field)
{
if (field == "") return "Не введен адрес электронной почты.\n"
else if (!((field.indexOf(".") > 0) &&
(field.indexOf("@") > 0)) ||
/[^a-zA-Z0-9.@_-]/.test(field))
return "Электронный адрес имеет неверный формат.\n"
return ""
}
</script>

-->

<table border="0" cellpadding="2" cellspacing="5"
bgcolor="#eeeeee">
<th colspan="2" align="center">Регистрационная форма</th>
<tr><td colspan="2">К сожалению, в вашей форме <br>
найдены следующие ошибки: <p><font color=red
size=1><i>$fail</i></font></p>
</td></tr>
<form method="post" action="js_17_mistakes.php" onSubmit="return
validate(this)">
<tr><td>Имя</td>
<td><input type="text" maxlength="32" name="forename"
value="forename">
</td></tr><tr><td>Фамилия</td>
<td><input type="text" maxlength="32" name="surname"
value="surname">
</td></tr><tr><td>Пользовательское имя</td>
<td><input type="text" maxlength="16" name="username"
value="username">
</td></tr><tr><td>Пароль</td>
<td><input type="text" maxlength="12" name="password"
value="password">
</td></tr><tr><td>Возраст</td>
<td><input type="text" maxlength="3" name="age" value="age">
</td></tr><tr><td>Электронный адрес</td>
<td><input type="text" maxlength="64" name="email"
value="email">
</td></tr><tr><td colspan="2" align="center"><input
type="submit" value="Зарегистрироваться"></td></tr>
</form>
</table>
_END;

// PHP-функции
function validate_forename($field)
{
	return ($field == "") ? "Не введено имя<br>" : "";

function validate_surname($field)
{
	return ($field == "") ? "Не введена фамилия<br>" : "";
}

function validate_username($field)
{
if ($field == "") return "Не введено имя пользователя<br>";
else if (strlen($field) < 5)
	return "В имени пользователя должно быть не менее 5 символов<br>";
else if (preg_match("/[^a-zA-Z0-9_-]/", $field))
	return "В имени пользователя допускаются только буквы, цифры, - и _<br>";
return "";
}

function validate_password($field)
{
if ($field == "") return "Не введен пароль<br>";
else if (strlen($field) < 6)
	return "В пароле должно быть не менее 6 символов<br>";
else if ( !preg_match("/[a-z]/", $field) ||
		!preg_match("/[A-Z]/", $field) ||
		!preg_match("/[0-9]/", $field))
	return "Пароль требует 1 символа из каждого набора a-z, A-Z и 0-9<br>";
return "";
}

function validate_age($field)
{
if ($field == "") return "Не введен возраст<br>";
else if ($field < 18 || $field > 110)
	return "Возраст должен быть между 18 и 110<br>";
return "";
}

function validate_email($field)
{
if ($field == "") return "Не введен адрес электронной почты<br>";
else if (!((strpos($field, ".") > 0) &&
		(strpos($field, "@") > 0)) ||
		preg_match("/[^a-zA-Z0-9.@_-]/", $field))
	return "Электронный адрес имеет неверный формат<br>";
return "";
}

function fix_string($string)
{
if (get_magic_quotes_gpc()) $string = stripslashes($string);
	return htmlentities ($string);
}

?

<p>
Если вы внимательно изучили этот пример (либо набрали или загрузили его с сопутствующего книге сайта),
то увидели, что код PHP является практически клоном кода JavaScript.
Для проверки каждого из полей в очень похожих функциях используются те же самые регулярные выражения.
</p>
<p>
Но здесь следует отметить две особенности.
Во-первых, для обезвреживания содержимого каждого поля и предотвращения любых попыток внедрения кода применяется функция fix_string,
которая находится в самом конце примера.
</p>
<p>
Во-вторых, вы должны были заметить, что код HTML из примера 17.1, повторенный в PHP-коде внутри структуры <<<_END... _END;,
отображает форму со значениями, которые посетитель ввел при предыдущей попытке заполнения формы.
Это сделано за счет простого добавления еще одного параметра value к каждому тегу input> (например, value="$forename").
Проявление такой заботы о пользователе всячески приветствуется, поскольку при этом ему не приходится снова и снова заполнять все поля,
а остается лишь отредактировать ранее введенные данные.
</p>


<p>
Вопрос 17.3<br>
Используя определения синтаксиса регулярных выражений, напишите такое регулярное выражение, которое будет соответствовать любым символам,
не использующимся в словах.
</p>
<p>
Ответ 17.3<br>
Регулярные выражения, соответствующие символам, не использующимся в словах, могут иметь вид:<br> /[^\w]/, /[\W]/, /[^a-zA-Z0-9_]/ и т. д.
</p>
<p>
Вопрос 17.4<br>
Напишите регулярное выражение, которое будет соответствовать как слову fox, так и слову fix.
</p>
<p>
Ответ 17.4<br>
Для проверки соответствия как слову fox, так и слову fix можно воспользоваться регулярным выражением:<br> /f[oi]x/.
</p>
<p>
Вопрос 17.5<br>
Напишите регулярное выражение, которое будет соответствовать любому отдельному слову, за которым следует любой символ, не использующийся в словах.
</p>
<p>
Ответ 17.5<br>
Регулярное выражение, соответствующее любому отдельному слову, за которым следует символ, не использующийся в словах, может иметь следующий вид:<br>
/\w+\W/g.
</p>
<p>
Вопрос 17.6<br>
Используя регулярное выражение, напишите функцию JavaScript, проверяющую наличие слова fox в строке The quick brown fox.
</p>
<p>
Ответ 17.6<br>
Функция JavaScript, использующая регулярное выражение для проверки наличия слова fox в строке The quick brown fox, может иметь такой вид:<br>
document.write(/fox/.test("The quick brown fox"))
</p>
<p>
Вопрос 17.7<br>
Используя регулярное выражение, напишите функцию PHP, заменяющую все экземпляры слова the в строке The cow jumps over the moon словом my.
</p>
<p>
Ответ 17.7<br>
Функция PHP, использующая регулярное выражение для замены всех экземпляров слова the в строке The cow jumps over the moon словом my,
может иметь следующий вид:<br>
$s=preg_replace("/the/i", "my", "The cow jumps over the moon");
</p>
<p>
Вопрос 17.2<br>
Какой метод JavaScript применяется для проверки соответствия строки регулярному выражению?
</p>
<p>
Ответ 17.2<br>
Для проверки соответствия строки регулярному выражению в JavaScript используется метод test.
</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>


<h4></h4>
<p>

</p>
<p></p>
<p>

</p>

<p style='color: blue;'>Start code</p>
<script>

</script>
<p>

</p>
<p>

</p>

		<p align="center">
		<a onclick="javascript: history.back(); return falshe;"><img src="../images/esc2.png" id="send"/></a>
		<a href="#top" title="Наверх"><img src="../images/buttonUpActive.png"/></a>
		</p>
		
	</body>
</html>