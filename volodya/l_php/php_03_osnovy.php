<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../css/screen.css" type="text/css" rel="stylesheet" />
<link rel="shortcut icon" type="image/ico" href="images/favicon.ico" />

<title>Основы</title>
</head>

	<body name="top">
<!-- !!!!!!!!!!!!!!!!!       шаблоны, заготовки для тэгов, комментарии !!!!!!!!!!!!!!! -->

<!-- Абзацы, заголовки, комментарии -->
<h4></h4>
<p>

</br>
</p>
<p></p>
<!-- Это комментарий HTML -->

<?php  ?>

<?php
/* 
Это область
многострочного комментария,
которая не будет
подвергаться интерпретации 
*/
?>

<!-- Шаблон для PHP кода с комментариями внутри кода -->
<h4></h4>
<p>

</br>
</p>
<p></p>
<?php
// 


// 

?>

<table>
	<tr><th></th><th></th><th></th></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
	<tr><td></td><td></td><td></td></tr>
</table>


<!-- !!!!!!!!!!!!!!!!!       шаблоны, заготовки для тэгов, комментарии !!!!!!!!!!!!!!! -->

		<?php
// внутри PHP-тегов встроенная функция date отображает текущий день недели, соответствующий системному времени сервера.
		echo " Today is " . date("l") . ". ";
		?>
		<p>Here's the latest news.</p>
		
<!-- PHP-конструкцию непосредственно рядом с кодом PHP -->
		<p>Today is <?php echo date("l"); ?>.</p>
		<p>Here's the latest news.</p>

<?php		
// Пример 3.3. Три разновидности присваивания значений переменным

$mycounter = 1;
$mystring = "Hello";

// Одномерные массивы
$myarray = array("One", "Two", "Three");
$team = array('Bill', 'Mary', 'Mike', 'Chris', 'Anne');

echo "$mycounter, $mystring, $myarray";
echo "<br>";
echo $team[3]; // Эта команда отображает имя Chris
echo "<br>";
?>

<?php
// Двухмерные массивы
// Пример 3.5. Определение двумерного массива

$oxo = array(array('x', ' ', 'o'),
array('o', 'o', 'x'),
array('x', 'o', ' ' ));

// Для возвращения в дальнейшем третьего элемента во второй строке этого массива можно воспользоваться следующей PHP-командой, которая отобразит символ «x»:
echo $oxo[1][2];

/*
Не забывайте о том, что отсчет индексов массива (указателей на элементы внутри массива) начинается с нуля, а не с единицы,
поэтому в предыдущей команде индекс [1] ссылается на второй из трех массивов, а индекс [2] — на третью позицию внутри этого массива.
Эта команда вернет содержимое третьего слева и второго сверху коробка.
*/
?>

<p>Не забывайте о том, что отсчет индексов массива (указателей на элементы внутри массива) начинается с нуля, а не с единицы,
поэтому в предыдущей команде индекс [1] ссылается на второй из трех массивов, а индекс [2] — на третью позицию внутри этого массива.
Эта команда вернет содержимое третьего слева и второго сверху коробка.</p>

<?php // test1.php
//Пример 3.4. Ваша первая PHP-программа

$username = "Fred Smith";
echo $username;
echo "<br>";
$current_user = $username;
echo $current_user;
?>

<h4>Таблица 3.1. Арифметические операторы</h4>
<table>
	<tr><th>Оператор</th><th>Описание</th><th>Пример</th></tr>
	<tr><td>+</td><td>Сложение</td><td>$j + 1</td></tr>
	<tr><td>–</td><td>Вычитание</td><td>$j – 6</td></tr>
	<tr><td>*</td><td>Умножение</td><td>$j * 11</td></tr>
	<tr><td>/</td><td>Деление</td><td>$j / 4</td></tr>
	<tr><td>%</td><td>Модуль (остаток от деления)</td><td>$j % 9</td></tr>
	<tr><td>++</td><td>Инкремент (приращение)</td><td>++$j</td></tr>
	<tr><td>––</td><td>Декремент (отрицательное приращение)</td><td>––$j</td></tr>
	<tr><td>.</td><td></td><td></td></tr>
</table>

<h4>Таблица 3.2. Операторы присваивания</h4>
<table>
	<tr><th>Оператор</th><th>Пример</th><th>Эквивалент</th></tr>
	<tr><td>=</td><td>$j = 15</td><td>$j = 15</td></tr>
	<tr><td>+=</td><td>$j += 5</td><td>$j = $j + 5</td></tr>
	<tr><td>-=</td><td>$j –= 3</td><td>$j = $j – 3</td></tr>
	<tr><td>*=/td><td>$j *= 8</td><td>$j = $j * 8</td></tr>
	<tr><td>/=</td><td>$j /= 16</td><td>$j = $j / 16</td></tr>
	<tr><td>.=</td><td>$j .= $k</td><td>$j = $j . $k</td></tr>
	<tr><td>%=</td><td>$j %= 4</td><td>$j = $j % 4</td></tr>
	<tr><td>++</td><td>++$x</td><td>$x = $x + 1</td></tr>
	<tr><td>--</td><td>--$y</td><td>$y = $y - 1</td></tr>
	<tr><td>.</td><td></td><td></td></tr>
</table>

<h4>Объединение строк</h4>
<?php
// Объединение строк

$msgs = 5;
// Самый простой способ объединения строк выглядит следующим образом:
echo "У вас " . $msgs . " сообщений.";
?>

<h4>Типы строк</h4>
<?php
// Если требуется присвоить переменной значение текстовой строки, сохраняя ее точное содержимое, нужно воспользоваться одинарными кавычками (апострофами):
$info = 'Предваряйте имена переменных символом $, как в данном примере: $variable';

// В то же время, если требуется включить в состав строки значение переменной, используется строка, заключенная в двойные кавычки:
echo "На этой неделе ваш профиль просмотрело $count человек ";
?>

<h4>Изменение предназначения символов</h4>
<p>
следующая строка кода не будет работать, потому что вторая кавычка (апостроф), встреченная в слове spelling's,
укажет PHP-парсеру на то, что достигнут конец строки.
</p>
<?php
//$text = 'My spelling's atroshus'; // Ошибочный синтаксис

// Для исправления ошибки нужно непосредственно перед вызывающим неоднозначное толкование символом кавычки добавить обратный слеш,
// чтобы заставить PHP рассматривать этот символ буквально и не подвергать его интерпретации:
$text = 'My spelling\'s still atroshus';

// Например, следующая строка, заключенная в двойные кавычки, будет присвоена переменной без ошибок:
$text = "She wrote upon it, \"Return to sender\".";

// Кроме того, для вставки в строку различных специальных символов, например табуляции, новой строки и возврата каретки,
// могут применяться управляющие символы:  \t, \n и \r соответственно.
$heading = "Дата\tИмя\tПлатеж";
?>

<h4>Типы переменных</h4>
<p>
$number = 12345 * 67890;</br>
echo substr($number, 3, 1);
</p>
<?php
// Пример 3.10. Автоматическое преобразование числа в строку

$number = 12345 * 67890;
echo substr($number, 3, 1);
// Когда присваивается значение, $number является числовой переменной.
// Но во второй строке кода вызов значения этой переменной помещен в PHP-функцию substr,
// которая должна вернуть из переменной $number один символ, стоящий на четвертой позиции (не забывайте, что в PHP отсчет позиции начинается с нуля).
// Для выполнения этой задачи PHP превращает $number в строку, состоящую из девяти символов, чтобы функция substr могла получить
// к ней доступ и вернуть символ, в данном случае 1.
?>

<p>
Когда присваивается значение, $number является числовой переменной.
Но во второй строке кода вызов значения этой переменной помещен в PHP-функцию substr,
которая должна вернуть из переменной $number один символ, стоящий на четвертой позиции
(не забывайте, что в PHP отсчет позиции начинается с нуля).
Для выполнения этой задачи PHP превращает $number в строку, состоящую из девяти символов,
чтобы функция substr могла получить к ней доступ и вернуть символ, в данном случае 1.
</p>

<h4>Константы</h4>
<p>К примеру, константа может использоваться для хранения местоположения корневого каталога вашего сервера
(папки, содержащей основные файлы вашего сайта). Определить такую константу можно следующим образом:</br>
define("ROOT_LOCATION", "/usr/local/www/");
</p>
<p>
Затем для чтения содержимого константы нужно просто сослаться на нее как на обычную переменную (но не предваряя ее имя знаком доллара):</br>

</p>
<p>Теперь, как только понадобится запустить ваш PHP-код на другом сервере с другой конфигурацией папок, придется изменить только одну строку кода.</p>
<?php
// 
define("ROOT_LOCATION", "/usr/local/www/");
$directory = ROOT_LOCATION;
// 
?>

<h4>Предопределенные константы</h4>
<p>Таблица 3.5. Волшебные константы PHP</p>
<table>
	<tr><th>Волшебная константа</th><th>Описание</th></tr>
	<tr><td>__LINE__</td><td>Номер текущей строки в файле</td></tr>
	<tr><td>__FILE__</td><td>Полное путевое имя файла. Если используется внутри инструкции include, то возвращается имя включенного файла. В версии PHP 4.0.2 __FILE__ всегда содержит абсолютный путь с раскрытыми символическими ссылками, а в предыдущих версиях при определенных обстоятельствах она может содержать относительный путь</td></tr>
	<tr><td>__DIR__</td><td>Каталог файла. Если используется внутри инструкции include, то возвращается каталог включенного файла. Такой же результат дает применение функции dirname(__FILE__). В этом имени каталога отсутствует замыкающий слеш, если только этот каталог не является корневым. (Добавлена в PHP 5.3.0)</td></tr>
	<tr><td>__FUNCTION__</td><td>Имя функции. Начиная с PHP 5, возвращает имя функции, под которым она была объявлена (с учетом регистра символов). В PHP 4 возвращаемое значение всегда составлено из символов нижнего регистра. (Добавлена в PHP 4.3.0)</td></tr>
	<tr><td>__CLASS__</td><td>Имя класса. Начиная с PHP 5, возвращает имя класса, под которым он был объявлен (с учетом регистра символов). В PHP 4 возвращаемое значение всегда составлено из символов нижнего регистра. (Добавлена в PHP 4.3.0)</td></tr>
	<tr><td>__METHOD__</td><td>Имя метода класса. Возвращает имя метода, под которым он был объявлен (с учетом регистра символов). (Добавлена в PHP 5.0.0)</td></tr>
	<tr><td>__NAMESPACE__</td><td>Имя текущего пространства имен (с учетом регистра символов). Эта константа определена во время компиляции. (Добавлена в PHP 5.3.0)</td></tr>
</table>

<p>Эти константы полезны при отладке, когда нужно вставить строку кода, чтобы понять, до какого места дошло выполнение программы:</br>
echo "Это строка " . __LINE__ . " в файле " . __FILE__ . " в каталоге " . __DIR__;</p>
<p>Эта команда выведет в браузер текущую строку программы с указанием текущего файла, исполняемого в данный момент (включая путь к нему).</p>
<?php 
// Это строка 238 в файле W:\domains\volodya\l_php\php_01_osnovy.php в каталоге W:\domains\volodya\l_php
echo "Это строка " . __LINE__ . " в файле " . __FILE__ . " в каталоге " . __DIR__;
?>

<h4>Различие между командами echo и print</h4>
<p>
Использование вопросительного знака — самый простой способ задать вопрос о том, какое значение имеет переменная $b, истинное или ложное.</br>
Команда, которая располагается слева от двоеточия, выполняется в том случае, если $b имеет истинное значение, а команда, которая располагается справа, выполняется, если $b имеет ложное значение.
</p>
<p>$b ? print "TRUE" : print "FALSE";</p>
<?php
$b ? print "TRUE" : print "FALSE"; 
?>

<h4>Функции</h4>
<p id="italic">
Чтобы создать функцию, нужно ее объявить, как показано в примере 3.12.</br>
Пример 3.12. Простое объявление функции</p>
<p id="bold">
function longdate($timestamp)
{
return date("l jS F Y", $timestamp);
}</p>
<p>
Эта функция использует в качестве входных данных отметку времени системы UNIX
(целое число, отображающее дату и время на основе количества секунд, прошедших с нуля часов 1 января 1970 года),
а затем вызывает PHP-функцию date с нужным форматом строки, чтобы вернуть дату в формате «Вторник май 2 2017».
</p>
<p>Чтобы с помощью этой функции вывести сегодняшнюю дату, нужно поместить в свой код следующий вызов:</br>
echo longdate(time());
</p>
<?php
function longdate($timestamp)
{
return date("l jS F  Y", $timestamp);
}

echo longdate(time()); // Вызов функции для вывода сегодняшней даты Wednesday 23rd December 2020
?>
<p>Если требуется вывести дату семнадцатидневной давности, нужно сделать следующий вызов:</br>
echo longdate(time() - 17 * 24 * 60 * 60);</br>
в котором функции longdate передается текущая отметка времени UNIX, уменьшенная на количество секунд,
прошедших за 17 дней (17 дней × 24 ч × 60 мин × 60 с).</p>
<?php echo longdate(time() - 17 * 24 * 60 * 60); ?>

<h4>Суперглобальные переменные</h4>
<p>Таблица 3.6. Суперглобальные переменные PHP</p>
<table>
	<tr><th>Имя суперглобальной переменной</th><th>Ее содержимое</th></tr>
	<tr><td>$GLOBALS</td><td>Все переменные, которые на данный момент определены в глобальной области видимости сценария. Имена переменных служат ключами массива</td></tr>
	<tr><td>$_SERVER</td><td>Информация о заголовках, путях, местах расположения сценариев. Элементы этого массива создаются веб-сервером, и это не дает гарантии, что каждый веб-сервер будет предоставлять какую-то часть информации или ее всю</td></tr>
	<tr><td>$_GET</td><td>Переменные, которые передаются текущему сценарию методом HTTP GET</td></tr>
	<tr><td>$_POST</td><td>Переменные, которые передаются текущему сценарию методом HTTP POST</td></tr>
	<tr><td>$_FILES</td><td>Элементы, подгруженные к текущему сценарию методом HTTP POST</td></tr>
	<tr><td>$_COOKIE</td><td>Переменные, переданные текущему сценарию посредством HTTP cookies</td></tr>
	<tr><td>$_SESSION</td><td>Переменные сессии, доступные текущему сценарию</td></tr>
	<tr><td>$_REQUEST</td><td>Содержимое информации, переданной от браузера; по умолчанию $_GET, $_POST и $_COOKIE</td></tr>
	<tr><td>$_ENV</td><td>Переменные, переданные текущему сценарию методом environment</td></tr>
</table>

<p>Среди многой другой интересной информации, предоставляемой суперглобальными переменными, есть и URL-адрес той страницы, с которой пользователь был перенаправлен на текущую веб-страницу.
Эта информация может быть получена следующим образом:</p>
<p id="bold">$came_from = $_SERVER['HTTP_REFERRER'];</p>

<p>Поэтому более подходящий способ доступа к $_SERVER (и другим суперглобальным переменным) выглядит следующим образом:</p>
<p id="bold">$came_from = htmlentities($_SERVER['HTTP_REFERRER']);</p>

<?php 
// Вы попали сюда с сайта:
$a = 1;
$came_from = $_SERVER['HTTP_REFERRER'];
echo "Вы попали сюда с сайта: " . $came_from . $a;

$came_from_1 = htmlentities($_SERVER['HTTP_REFERRER']);
echo "Вы попали сюда с сайта: " . $came_from_1 . $a;
?>

<p id="italic">Использование для санации функции htmlentities считается важной практикой не только в отношении суперглобальных переменных,
но и при любых обстоятельствах, в которых данные, исходящие от пользователя или поступающие из сторонних источников,
обрабатываются для получения выходных данных.</p>

		<p align="center">
		<a onclick="javascript: history.back(); return falshe;"><img src="../images/esc2.png" id="send"/></a>
		<a href="#top" title="Наверх"><img src="../images/buttonUpActive.png"/></a>
		</p>
	</body>
</html>